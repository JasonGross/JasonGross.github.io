<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Tutorial on the new proof engine for ML tactic writers | Jason Gross</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Tutorial on the new proof engine for ML tactic writers" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Personal website of Jason Gross" />
<meta property="og:description" content="Personal website of Jason Gross" />
<link rel="canonical" href="http://localhost:4000/presentations/coq-workshop-2018-coq/dev/doc/proof-engine.html" />
<meta property="og:url" content="http://localhost:4000/presentations/coq-workshop-2018-coq/dev/doc/proof-engine.html" />
<meta property="og:site_name" content="Jason Gross" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Tutorial on the new proof engine for ML tactic writers" />
<script type="application/ld+json">
{"@type":"WebPage","url":"http://localhost:4000/presentations/coq-workshop-2018-coq/dev/doc/proof-engine.html","headline":"Tutorial on the new proof engine for ML tactic writers","description":"Personal website of Jason Gross","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Jason Gross" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Jason Gross</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/">Jason Gross</a><a class="page-link" href="/papers/lob-paper/README-SUPPLEMENTAL.html">Lӧb’s Theorem: A functional pearl of dependently typed quining</a><a class="page-link" href="/papers/source/fiat-crypto/pldi-2017/rebuttal.html">General Clarifications</a><a class="page-link" href="/papers/source/fiat-crypto/popl-2018/reviews.html">POPL ‘18 Paper #2 Reviews and Comments</a><a class="page-link" href="/papers/source/lob-paper/README-SUPPLEMENTAL.html">Lӧb’s Theorem: A functional pearl of dependently typed quining</a><a class="page-link" href="/papers/source/rewriting/rewriting.html">Rewriter</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/doc/changes.html">Changes between Coq 8.7 and Coq 8.8</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/doc/debugging.html">Debugging from Coq toplevel using Caml trace mechanism</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/doc/econstr.html">Evar-insensitive terms (EConstr)</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/doc/proof-engine.html">Tutorial on the new proof engine for ML tactic writers</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/doc/xml-protocol.html">Coq XML Protocol</a><a class="page-link" href="/papers/lob-paper/">Lӧb’s Theorem: A functional pearl of dependently typed quining</a><a class="page-link" href="/papers/source/lob-paper/">Lӧb’s Theorem: A functional pearl of dependently typed quining</a><a class="page-link" href="/presentations/coq-8.6-wishlist/">coq-8.6-wishlist</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/">Coq</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/ci/">Continuous Integration for the Coq Proof Assistant</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/ci/user-overlays/">Add overlays for your pull requests in this directory</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/test-suite/">Coq Test Suite</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Tutorial on the new proof engine for ML tactic writers</h1>
  </header>

  <div class="post-content">
    <h1 id="tutorial-on-the-new-proof-engine-for-ml-tactic-writers">Tutorial on the new proof engine for ML tactic writers</h1>

<p>Starting from Coq 8.5, a new proof engine has been introduced, replacing the old
meta-based engine which had a lot of drawbacks, ranging from expressivity to
soundness, the major one being that the type of tactics was transparent. This
was pervasively abused and made virtually impossible to tweak the implementation
of the engine.</p>

<p>The old engine is deprecated and is slowly getting removed from the source code.</p>

<p>The new engine relies on a monadic API defined in the <code class="language-plaintext highlighter-rouge">Proofview</code> module. Helper
functions and higher-level operations are defined in the <code class="language-plaintext highlighter-rouge">Tacmach</code> and
<code class="language-plaintext highlighter-rouge">Tacticals</code> modules, and end-user tactics are defined amongst other in the
<code class="language-plaintext highlighter-rouge">Tactics</code> module.</p>

<p>At the root of the engine is a representation of proofs as partial terms that
can contain typed holes, called evars, short for <em>existential variable</em>. An evar
is essentially defined by its context and return type, that we will write
<code class="language-plaintext highlighter-rouge">?e : [Γ ⊢ _ : A]</code>. An evar <code class="language-plaintext highlighter-rouge">?e</code> must be applied to a substitution <code class="language-plaintext highlighter-rouge">σ</code> of type
<code class="language-plaintext highlighter-rouge">Γ</code> (i.e. a list of terms) to produce a term of type <code class="language-plaintext highlighter-rouge">A</code>, which is done by
applying <code class="language-plaintext highlighter-rouge">EConstr.mkEvar</code>, and which we will write <code class="language-plaintext highlighter-rouge">?e{σ}</code>.</p>

<p>The engine monad features a notion of global state called <code class="language-plaintext highlighter-rouge">evar_map</code>, defined in
the <code class="language-plaintext highlighter-rouge">Evd</code> module, which is the structure containing the incremental refinement
of evars. <code class="language-plaintext highlighter-rouge">Evd</code> is a low-level API and its use is discouraged in favour of the
<code class="language-plaintext highlighter-rouge">Evarutil</code> module which provides more abstract primitives.</p>

<p>In addition to this state, the monad also features a goal state, that is
an ordered list of current holes to be filled. While these holes are referred
to as goals at a high-enough level, they are actually no more than evars. The
API provided to deal with these holes can be found in the <code class="language-plaintext highlighter-rouge">Proofview.Goal</code>
module. Tactics are naturally operating on several goals at once, so that it is
usual to use the <code class="language-plaintext highlighter-rouge">Proofview.Goal.enter</code> function and its variants to dispatch a
tactic to each of the goals under focus.</p>

<h2 id="primitive-tactics-by-term-refining">Primitive tactics by term refining</h2>

<p>A typical low-level tactic will be defined by plugging partial terms in the
goal holes thanks to the <code class="language-plaintext highlighter-rouge">Refine</code> module, and in particular to the
<code class="language-plaintext highlighter-rouge">Refine.refine</code> primitive.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">refine</span> <span class="o">:</span> <span class="n">typecheck</span><span class="o">:</span><span class="kt">bool</span> <span class="o">-&gt;</span> <span class="nn">Constr</span><span class="p">.</span><span class="n">t</span> <span class="nn">Sigma</span><span class="p">.</span><span class="n">run</span> <span class="o">-&gt;</span> <span class="kt">unit</span> <span class="n">tactic</span>
<span class="c">(** In [refine typecheck t], [t] is a term with holes under some
    [evar_map] context. The term [t] is used as a partial solution
    for the current goal (refine is a goal-dependent tactic), the
    new holes created by [t] become the new subgoals. Exceptions
    raised during the interpretation of [t] are caught and result in
    tactic failures. If [typecheck] is [true] [t] is type-checked beforehand. *)</span>
</code></pre></div></div>

<p>In a first approximation, we can think of <code class="language-plaintext highlighter-rouge">'a Sigma.run</code> as
<code class="language-plaintext highlighter-rouge">evar_map -&gt; 'a * evar_map</code>. What the function does is first evaluate the
<code class="language-plaintext highlighter-rouge">Constr.t Sigma.run</code> argument in the current proof state, and then use the
resulting term as a filler for the proof under focus. All evars that have been
created by the invocation of this thunk are then turned into new goals added in
the order of their creation.</p>

<p>To see how we can use it, let us have a look at an idealized example, the <code class="language-plaintext highlighter-rouge">cut</code>
tactic. Assuming <code class="language-plaintext highlighter-rouge">X</code> is a type, <code class="language-plaintext highlighter-rouge">cut X</code> fills the current goal <code class="language-plaintext highlighter-rouge">[Γ ⊢ _ : A]</code>
with a term <code class="language-plaintext highlighter-rouge">let x : X := ?e2{Γ} in ?e1{Γ} x</code> where <code class="language-plaintext highlighter-rouge">x</code> is a fresh variable and
<code class="language-plaintext highlighter-rouge">?e1 : [Γ ⊢ _ : X -&gt; A]</code> and <code class="language-plaintext highlighter-rouge">?e2 : [Γ ⊢ _ : X]</code>. The current goal is solved and
two new holes <code class="language-plaintext highlighter-rouge">[e1, e2]</code> are added to the goal state in this order.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">cut</span> <span class="n">c</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">open</span> <span class="nc">Sigma</span> <span class="k">in</span>
  <span class="nn">Proofview</span><span class="p">.</span><span class="nn">Goal</span><span class="p">.</span><span class="n">nf_enter</span> <span class="p">{</span> <span class="n">enter</span> <span class="o">=</span> <span class="k">begin</span> <span class="k">fun</span> <span class="n">gl</span> <span class="o">-&gt;</span>
    <span class="c">(** In this block, we focus on one goal at a time indicated by gl *)</span>
    <span class="k">let</span> <span class="n">env</span> <span class="o">=</span> <span class="nn">Proofview</span><span class="p">.</span><span class="nn">Goal</span><span class="p">.</span><span class="n">env</span> <span class="n">gl</span> <span class="k">in</span>
    <span class="c">(** Get the context of the goal, essentially [Γ] *)</span>
    <span class="k">let</span> <span class="n">concl</span> <span class="o">=</span> <span class="nn">Proofview</span><span class="p">.</span><span class="nn">Goal</span><span class="p">.</span><span class="n">concl</span> <span class="n">gl</span> <span class="k">in</span>
    <span class="c">(** Get the conclusion [A] of the goal *)</span>
    <span class="k">let</span> <span class="n">hyps</span> <span class="o">=</span> <span class="nn">Tacmach</span><span class="p">.</span><span class="nn">New</span><span class="p">.</span><span class="n">pf_ids_of_hyps</span> <span class="n">gl</span> <span class="k">in</span>
    <span class="c">(** List of hypotheses from the context of the goal *)</span>
    <span class="k">let</span> <span class="n">id</span> <span class="o">=</span> <span class="nn">Namegen</span><span class="p">.</span><span class="n">next_name_away</span> <span class="nc">Anonymous</span> <span class="n">hyps</span> <span class="k">in</span>
    <span class="c">(** Generate a fresh identifier *)</span>
    <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mkArrow</span> <span class="n">c</span> <span class="p">(</span><span class="nn">Vars</span><span class="p">.</span><span class="n">lift</span> <span class="mi">1</span> <span class="n">concl</span><span class="p">)</span> <span class="k">in</span>
    <span class="c">(** Build [X -&gt; A]. Note the lifting of [A] due to being on the right hand
        side of the arrow. *)</span>
    <span class="nn">Refine</span><span class="p">.</span><span class="n">refine</span> <span class="p">{</span> <span class="n">run</span> <span class="o">=</span> <span class="k">begin</span> <span class="k">fun</span> <span class="n">sigma</span> <span class="o">-&gt;</span>
      <span class="c">(** All evars generated by this block will be added as goals *)</span>
      <span class="k">let</span> <span class="nc">Sigma</span> <span class="p">(</span><span class="n">f</span><span class="o">,</span> <span class="n">sigma</span><span class="o">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="nn">Evarutil</span><span class="p">.</span><span class="n">new_evar</span> <span class="n">env</span> <span class="n">sigma</span> <span class="n">t</span> <span class="k">in</span>
      <span class="c">(** Generate ?e1 : [Γ ⊢ _ : X -&gt; A], add it to sigma, and return the
          term [f := Γ ⊢ ?e1{Γ} : X -&gt; A] with the updated sigma. The identity
          substitution for [Γ] is extracted from the [env] argument, so that
          one must be careful to pass the correct context here in order for the
          resulting term to be well-typed. The [p] return value is a proof term
          used to enforce sigma monotonicity. *)</span>
      <span class="k">let</span> <span class="nc">Sigma</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">sigma</span><span class="o">,</span> <span class="n">q</span><span class="p">)</span> <span class="o">=</span> <span class="nn">Evarutil</span><span class="p">.</span><span class="n">new_evar</span> <span class="n">env</span> <span class="n">sigma</span> <span class="n">c</span> <span class="k">in</span>
      <span class="c">(** Generate ?e2 : [Γ ⊢ _ : X] in sigma and return
          [x := Γ ⊢ ?e2{Γ} : X]. *)</span>
      <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">mkLetIn</span> <span class="p">(</span><span class="nc">Name</span> <span class="n">id</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">mkApp</span> <span class="p">(</span><span class="nn">Vars</span><span class="p">.</span><span class="n">lift</span> <span class="mi">1</span> <span class="n">r</span><span class="o">,</span> <span class="p">[</span><span class="o">|</span><span class="n">mkRel</span> <span class="mi">1</span><span class="o">|</span><span class="p">]))</span> <span class="k">in</span>
      <span class="c">(** Build [r := Γ ⊢ let id : X := ?e2{Γ} in ?e1{Γ} id : A] *)</span>
      <span class="nc">Sigma</span> <span class="p">(</span><span class="n">r</span><span class="o">,</span> <span class="n">sigma</span><span class="o">,</span> <span class="n">p</span> <span class="o">+&gt;</span> <span class="n">q</span><span class="p">)</span>
      <span class="c">(** Fills the current hole with [r]. The [p +&gt; q] thingy ensures
          monotonicity of sigma. *)</span>
    <span class="k">end</span> <span class="p">}</span>
  <span class="k">end</span> <span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Evarutil.new_evar</code> function is the preferred way to generate evars in
tactics. It returns a ready-to-use term, so that one does not have to call
the <code class="language-plaintext highlighter-rouge">mkEvar</code> primitive. There are lower-level variants whose use is dedicated to
special use cases, <em>e.g.</em> whenever one wants a non-identity substitution. One
should take care to call it with the proper <code class="language-plaintext highlighter-rouge">env</code> argument so that the evar
and term it generates make sense in the context they will be plugged in.</p>

<p>For the sake of completeness, the old engine was relying on the <code class="language-plaintext highlighter-rouge">Tacmach.refine</code>
function to provide a similar feature. Nonetheless, it was using untyped metas
instead of evars, so that it had to mangle the argument term to actually produce
the term that would be put into the hole. For instance, to work around the
untypedness, some metas had to be coerced with a cast to enforce their type,
otherwise leading to runtime errors. This was working for very simple
instances, but was unreliable for everything else.</p>

<h2 id="high-level-composition-of-tactics">High-level composition of tactics</h2>

<p>It is possible to combine low-level refinement tactics to create more powerful
abstractions. While it was the standard way of doing things in the old engine
to overcome its technical limitations (namely that one was forced to go through
a limited set of derivation rules), it is recommended to generate proofs as
much as possible by refining in ML tactics when it is possible and easy enough.
Indeed, this prevents dependence on fragile constructions such as unification.</p>

<p>Obviously, it does not forbid the use of tacticals to mimick what one would do
in Ltac. Each Ltac primitive has a corresponding ML counterpart with simple
semantics. A list of such tacticals can be found in the <code class="language-plaintext highlighter-rouge">Tacticals</code> module. Most
of them are a porting of the tacticals from the old engine to the new one, so
that if they share the same name they are expected to have the same semantics.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Jason Gross</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Jason Gross</li><li><a class="u-email" href="mailto:jgross@mit.edu">jgross@mit.edu</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/JasonGross"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">JasonGross</span></a></li><li><a href="https://www.twitter.com/diagram_chaser"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">diagram_chaser</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Personal website of Jason Gross</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
