<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Jason Gross | Personal website of Jason Gross</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Jason Gross" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Personal website of Jason Gross" />
<meta property="og:description" content="Personal website of Jason Gross" />
<link rel="canonical" href="http://localhost:4000/papers/2016-lob-icfp-2016-reviews/review-responses.html" />
<meta property="og:url" content="http://localhost:4000/papers/2016-lob-icfp-2016-reviews/review-responses.html" />
<meta property="og:site_name" content="Jason Gross" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Jason Gross" />
<script type="application/ld+json">
{"@type":"WebPage","url":"http://localhost:4000/papers/2016-lob-icfp-2016-reviews/review-responses.html","headline":"Jason Gross","description":"Personal website of Jason Gross","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Jason Gross" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Jason Gross</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/">Jason Gross</a><a class="page-link" href="/papers/lob-paper/README-SUPPLEMENTAL.html">Lӧb’s Theorem: A functional pearl of dependently typed quining</a><a class="page-link" href="/papers/source/fiat-crypto/pldi-2017/rebuttal.html">General Clarifications</a><a class="page-link" href="/papers/source/fiat-crypto/popl-2018/reviews.html">POPL ‘18 Paper #2 Reviews and Comments</a><a class="page-link" href="/papers/source/lob-paper/README-SUPPLEMENTAL.html">Lӧb’s Theorem: A functional pearl of dependently typed quining</a><a class="page-link" href="/papers/source/rewriting/rewriting.html">Rewriter</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/doc/changes.html">Changes between Coq 8.7 and Coq 8.8</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/doc/debugging.html">Debugging from Coq toplevel using Caml trace mechanism</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/doc/econstr.html">Evar-insensitive terms (EConstr)</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/doc/proof-engine.html">Tutorial on the new proof engine for ML tactic writers</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/doc/xml-protocol.html">Coq XML Protocol</a><a class="page-link" href="/papers/lob-paper/">Lӧb’s Theorem: A functional pearl of dependently typed quining</a><a class="page-link" href="/papers/source/lob-paper/">Lӧb’s Theorem: A functional pearl of dependently typed quining</a><a class="page-link" href="/presentations/coq-8.6-wishlist/">coq-8.6-wishlist</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/">Coq</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/ci/">Continuous Integration for the Coq Proof Assistant</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/ci/user-overlays/">Add overlays for your pull requests in this directory</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/test-suite/">Coq Test Suite</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title"></h1>
  </header>

  <div class="post-content">
    <p>Thank you all for the feedback; we really appreciate it.</p>

<p>It’s now clear that one of the most subtle parts of Lӧb’s theorem is distinguishing between semantics, syntax, quoted syntax, and doubly-quoted syntax, and that our paper does not make it easy enough to make these distinctions; we will edit the paper to do far more hand-holding here, and will drop the cute notations that blur this distinction.  The points about cute notations and magic tricks, and about consistently using the same words for the same concepts, are well-taken, and we will fix these things.</p>

<p>The suggestion to begin with the Y combinator is a good one; thank you reviewers B and C!</p>

<p>We now realize that the traditional presentation of Curry-Howard is classical and identifies provability with truth; to extend it neatly to talking about provability logic in a computational manner, we’ve presented it in from within the lens of Brouwer’s intuitionism; we will clarify our use of the word “truth”.</p>

<p>Reviewer-specific responses, followed by an appendix of reviewer-specific responses that didn’t fit in the first 500 words.</p>

<p>========================</p>

<h2 id="reviewer-a">Reviewer A:</h2>

<p>Indeed, it seems impossible at first glance to prove Lӧb’s theorem without some sort of <code class="language-plaintext highlighter-rouge">QUINE</code> primitive.  But it turns out it is possible!  Section 10 sketches how to do this, and we flesh it out for those interested in the supplemental material.</p>

<p>Your point about cute names is well-taken, and the use of capitalization to distinguish the syntax for types from the syntax for terms, and using names rather than symbols to distinguish syntax from semantics, are both great ideas.</p>

<p>========================</p>

<h2 id="reviewer-b">Reviewer B:</h2>

<ul>
  <li>
    <p>The Y combinator is unsound in a proof assistant; non-termination leads to proofs of false.  Indeed, Lӧb’s theorem is nothing but a variant of the Y combinator with (un)quoting, <em>which implicitly forbids infinite loops</em>.  We will make clear that this paper is implementing this variant of the Y combinator in varying degrees of detail, in a way that is terminating-by-construction.</p>
  </li>
  <li>
    <p>The type <code class="language-plaintext highlighter-rouge">□ (‘□’ X ‘→’ X) → □ X</code> corresponds to the deduction rule “from <code class="language-plaintext highlighter-rouge">⊢ □ X → X</code>, we deduce <code class="language-plaintext highlighter-rouge">⊢ X</code>”.  An alternative would be “<code class="language-plaintext highlighter-rouge">⊢ □ (□ X → X) → □ X</code>”.</p>
  </li>
</ul>

<p>========================</p>

<h2 id="reviewer-c">Reviewer C:</h2>

<p>If we understand correctly, you want to see us separate the proof of Lӧb’s theorem from its semantics, using a variant of S4.</p>

<p>This is a good idea, and we may replace the section that assumes a quine with this formalization (see the appendix to this note for a 40 line version).</p>

<ul>
  <li>We assumed that for those unfamiliar with encodings of type theory in type theory, working with strings and string replacement and quotation in Python would be more familiar than working with quotation and substitution on abstract syntax trees.  We acknowledge that it might be clearer to present the quotation operation from scratch, rather than relying on intuition from Python.  (Note that internally implementing quotation on well-typed syntax trees is, as far as we are aware, still an open problem, implementation-wise.)</li>
</ul>

<p>========================
Appendix
========================</p>

<p>========================</p>

<h2 id="reviewer-a-1">Reviewer A:</h2>

<p>I’m a bit confused by your second bit of code; the type of <code class="language-plaintext highlighter-rouge">LÖB</code> should be <code class="language-plaintext highlighter-rouge">EXP → EXP</code>, and <code class="language-plaintext highlighter-rouge">löb</code> should have type</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>löb : {T : TYP} {interp : EXP} → interp ∶ (ARR (BOX T) T) → (LÖB interp ∶ T)
</code></pre></div></div>

<p>Your hole can be filled with <code class="language-plaintext highlighter-rouge">Σ EXP (λ e → e ∶ T)</code>, and the denotation function for <code class="language-plaintext highlighter-rouge">EXP</code> is the same as in your first block of code.</p>

<p>What you are doing here, I think, is separating raw terms from their typing judgments.  What we do is remove the <code class="language-plaintext highlighter-rouge">LÖB</code> primitive and reimplement it using a <code class="language-plaintext highlighter-rouge">QUINE</code> primitive, and then sketch how that can be removed entirely.</p>

<p>We’d be curious to see these references in the context of quantum computation; I’ve not seen any physical interpretation of the modal □ operator.</p>

<p>========================</p>

<h2 id="reviewer-b-1">Reviewer B:</h2>

<ul>
  <li>
    <p>The proof of Lӧb’s theorem uses self-reference in an essential way; it results from analyzing the self-referential sentence “If this sentence is provable, then A”.  We explain that this is used to prove Lӧb’s theorem in the second-to-last paragraph in the introduction, containing “This, in a nutshell, is Löb’s theorem.”  We’d very much appreciate suggestions on what made this unclear.</p>
  </li>
  <li>
    <p>Thank you for the suggestions about unifying the synonyms and clarifying types where they are not obvious; we’ll do this.</p>
  </li>
  <li>
    <p>The relation between the program <code class="language-plaintext highlighter-rouge">Lob(X)</code> on page 2 and <code class="language-plaintext highlighter-rouge">□(□A → A) → □A</code> is that <code class="language-plaintext highlighter-rouge">Lob(X)</code> is the key ingredient of the proof of Löb’s theorem; it is the type corresponding to the sentence “If this sentence is provable, then A” which is mentioned above.</p>
  </li>
  <li>
    <p>Interpreting <code class="language-plaintext highlighter-rouge">□A</code> as <code class="language-plaintext highlighter-rouge">1 → A</code> does not fix the termination problem.  It is possible to have a total language with a Löbian combinator <code class="language-plaintext highlighter-rouge">(□A → A) → A</code> if we interpret <code class="language-plaintext highlighter-rouge">□A</code> as syntax, but if we interpret it as <code class="language-plaintext highlighter-rouge">1 → A</code>, we get <code class="language-plaintext highlighter-rouge">((1 → A) → A) → A</code>, which is just the Y combinator.  Said another way, <code class="language-plaintext highlighter-rouge">1 → A</code> suspends computation at <em>runtime</em>, but to make Lӧb’s theorem work, we must suspend computation at <em>compile-time</em>.</p>
  </li>
  <li>
    <p>Regarding <code class="language-plaintext highlighter-rouge">repr</code>, we can <em>add</em> a level of quotation to anything that’s already quoted.  We plan to make it easier to see at a glance the distinction between semantics, (singly-quoted) syntax, and (doubly) quoted syntax.</p>
  </li>
  <li>
    <p>Regarding “There is no syntactic proof of absurdity”, we again need to make clearer the distinction between syntax and semantics.  Agda has no proof of absurdity.  If we build our syntax in a stupid way, we might permit a syntactic proof of absurdity in the object language (which is not the full extent of Agda, and which we have no guarantee is identical to a subset of Agda); we must prove that it is impossible to derive contradictions in our object language.</p>
  </li>
  <li>
    <p>Regarding the footnote, <code class="language-plaintext highlighter-rouge">□(□X → X) → □X</code> is a valid expression of the type of Lӧb’s theorem, but it’s not a valid type for a constructor of an inductive datatype <code class="language-plaintext highlighter-rouge">□</code>, again for termination (positivity) reasons.</p>
  </li>
  <li>
    <p>Thank you for the feedback on the Prisoner’s dilemma section; we will add a bit more exposition to make it more self-contained.</p>
  </li>
  <li>
    <p>Agda does not have a notion of truth distinct from provability; this is what we meant by “banish [the word] ‘truth’”.  We will add more hand-holding here; the reason to talk about “provability” is that it is extremely confusing to say “P is false, and ‘P is false’ is false” while it is only mildly confusing to say “we can prove that P is absurd, but we can also prove that proving “WE CAN PROVE THAT P IS ABSURD” is absurd”.</p>
  </li>
</ul>

<p>========================</p>

<h2 id="reviewer-c-1">Reviewer C:</h2>

<p>The formalization and semantics of S4, specializing the quine/fixed-point theorem to the Lӧbian sentence.  We may use this to replace the formalization based on the Quine primitive (obviously with added explanation of the Lӧb′s-Theorem proof term).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data TYP : Set where
  ARR : TYP → TYP → TYP -- the type of implications, or function types
  BOX : TYP → TYP -- the modal □ operator, denoted to TERM
  LӦB-SENTENCE : TYP → TYP -- the Lӧbian sentence "If this sentence is provable, then A"
                           -- this is the modal fixpoint of λ Ψ. □ Ψ → A

data TERM : TYP → Set where
  nec : {A : TYP} → TERM A → TERM (BOX A)                                             -- from A, we deduce □ A
  distr : {A B : TYP} → TERM (ARR (BOX (ARR A B)) (ARR (BOX A) (BOX B)))              -- we deduce □ (A → B) → □ A → □ B
  s4 : {A : TYP} → TERM (ARR (BOX A) (BOX (BOX A)))                                   -- we deduce □ A →  □ □ A
  app : {A B : TYP} → TERM (ARR A B) → TERM A → TERM B                                -- from A → B, and A, we deduce B
  lӧb→ : {A : TYP} → TERM (ARR (LӦB-SENTENCE A) (ARR (BOX (LӦB-SENTENCE A)) A))       -- LӦB-SENTENCE A is Ψ such that Ψ → (□ Ψ → A)
  lӧb← : {A : TYP} → TERM (ARR (ARR (BOX (LӦB-SENTENCE A)) A) (LӦB-SENTENCE A))       -- LӦB-SENTENCE A is Ψ such that (□ Ψ → A) → Ψ
  compose : {A B C : TYP} → TERM (ARR A B) → TERM (ARR B C) → TERM (ARR A C)          -- from A → B and B → C, we deduce A → C
  compose2 : {A B C : TYP} → TERM (ARR A B) → TERM (ARR A (ARR B C)) → TERM (ARR A C) -- from A → B and A → B → C, we deduce A → C

Lӧb′s-Theorem : {A : TYP} → TERM (ARR (BOX A) A) → TERM A -- from □ A → A, we deduce A
Lӧb′s-Theorem {A} refl-rule = app prog (nec (app lӧb← prog))
  where prog : TERM (ARR (BOX (LӦB-SENTENCE A)) A)
        prog = compose (compose2 s4 (compose (app distr (nec lӧb→)) distr)) refl-rule

⟦_⟧ᵀ : TYP → Set
⟦ ARR A B ⟧ᵀ = ⟦ A ⟧ᵀ → ⟦ B ⟧ᵀ
⟦ BOX T ⟧ᵀ = TERM T
⟦ LӦB-SENTENCE A ⟧ᵀ = TERM (LӦB-SENTENCE A) → ⟦ A ⟧ᵀ

⟦_⟧ᵗ : {T : TYP} → TERM T → ⟦ T ⟧ᵀ
⟦ nec e ⟧ᵗ = e
⟦ distr ⟧ᵗ box-a-b box-a = app box-a-b box-a
⟦ s4 ⟧ᵗ = nec
⟦ app f x ⟧ᵗ = ⟦ f ⟧ᵗ ⟦ x ⟧ᵗ
⟦ lӧb→ ⟧ᵗ = λ x → x -- this implication is true because on denotation, the two are judgmentally equal
⟦ lӧb← ⟧ᵗ = λ x → x -- this implication is true because on denotation, the two are judgmentally equal
⟦ compose f g ⟧ᵗ = λ x → ⟦ g ⟧ᵗ (⟦ f ⟧ᵗ x)
⟦ compose2 f g ⟧ᵗ = λ x → ⟦ g ⟧ᵗ x (⟦ f ⟧ᵗ x)
</code></pre></div></div>

<ul>
  <li>Section 3 is intended to be a crash course in formalizing the syntax and semantics of type theory for those who have not seen it before.  Perhaps your point is that it does not provide enough explanation for those unfamiliar with it, that it is (intentionally) irrelevant for those familiar with formalizing type theory in type theory, and that what little content in the section falls into neither category should be merged into the other sections, to improve flow.  This is a good point.</li>
</ul>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Jason Gross</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Jason Gross</li><li><a class="u-email" href="mailto:jgross@mit.edu">jgross@mit.edu</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/JasonGross"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">JasonGross</span></a></li><li><a href="https://www.twitter.com/diagram_chaser"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">diagram_chaser</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Personal website of Jason Gross</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
