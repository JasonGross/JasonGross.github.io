<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>General Clarifications | Jason Gross</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="General Clarifications" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Personal website of Jason Gross" />
<meta property="og:description" content="Personal website of Jason Gross" />
<link rel="canonical" href="http://localhost:4000/papers/source/fiat-crypto/pldi-2017/rebuttal.html" />
<meta property="og:url" content="http://localhost:4000/papers/source/fiat-crypto/pldi-2017/rebuttal.html" />
<meta property="og:site_name" content="Jason Gross" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="General Clarifications" />
<script type="application/ld+json">
{"@type":"WebPage","url":"http://localhost:4000/papers/source/fiat-crypto/pldi-2017/rebuttal.html","headline":"General Clarifications","description":"Personal website of Jason Gross","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Jason Gross" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Jason Gross</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/">Jason Gross</a><a class="page-link" href="/papers/lob-paper/README-SUPPLEMENTAL.html">Lӧb’s Theorem: A functional pearl of dependently typed quining</a><a class="page-link" href="/papers/source/fiat-crypto/pldi-2017/rebuttal.html">General Clarifications</a><a class="page-link" href="/papers/source/fiat-crypto/popl-2018/reviews.html">POPL ‘18 Paper #2 Reviews and Comments</a><a class="page-link" href="/papers/source/lob-paper/README-SUPPLEMENTAL.html">Lӧb’s Theorem: A functional pearl of dependently typed quining</a><a class="page-link" href="/papers/source/rewriting/rewriting.html">Rewriter</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/doc/changes.html">Changes between Coq 8.7 and Coq 8.8</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/doc/debugging.html">Debugging from Coq toplevel using Caml trace mechanism</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/doc/econstr.html">Evar-insensitive terms (EConstr)</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/doc/proof-engine.html">Tutorial on the new proof engine for ML tactic writers</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/doc/xml-protocol.html">Coq XML Protocol</a><a class="page-link" href="/papers/lob-paper/">Lӧb’s Theorem: A functional pearl of dependently typed quining</a><a class="page-link" href="/papers/source/lob-paper/">Lӧb’s Theorem: A functional pearl of dependently typed quining</a><a class="page-link" href="/presentations/coq-8.6-wishlist/">coq-8.6-wishlist</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/">Coq</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/ci/">Continuous Integration for the Coq Proof Assistant</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/dev/ci/user-overlays/">Add overlays for your pull requests in this directory</a><a class="page-link" href="/presentations/coq-workshop-2018-coq/test-suite/">Coq Test Suite</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">General Clarifications</h1>
  </header>

  <div class="post-content">
    <h1 id="general-clarifications">General Clarifications</h1>

<h2 id="synthesis">“Synthesis”</h2>

<p>It’s true that our pipeline is “synthesis” in only a limited sense, and that
was evidently an unfortunate choice of wording for a PLDI audience. We process
code in two steps: (1) verifying optimizations in a generic way and (2)
compiling code (with specific parameters instantiated) that applies those
optimizations. The first is done mostly manually, but is done once for wide
classes of curves. The second is done mostly automatically, with minimal human
input (specifically, a JSON file like the one shown in section 6.3). There is
no search process involved.</p>

<h2 id="haskell">Haskell</h2>

<p>Our output was a syntax tree of simple, assembly-like operations[0]. The
performance-critical leaf functions could easily be pretty-printed to C or
any other language that supports fixed-size integers. The final product does not
depend on any specifics of Haskell or GHC, though for convenience we used them
for the performance experiments reported in the paper. Writing a verified compiler that
performs efficient register allocation and produces code for a sufficient subset
of architectures would be another project in itself.</p>

<h2 id="scope">Scope</h2>

<p>We’d like to clarify which formal claims we aim to establish for particular
generated pieces of code.  Given a cryptography implementation, there are two main
kinds of security vulnerabilities to worry about.</p>

<ol>
  <li>The protocol being implemented might not have the properties it claims.</li>
  <li>The implementation may fail to correctly implement the protocol.</li>
</ol>

<p>We are focused entirely on the second question. Implementation correctness is a
significant source of bugs and, due to intense optimization efforts, contains
complex reasoning. However, there is no real “attacker model” needed for this
problem.</p>

<h2 id="side-channels">“Side channels”</h2>

<p>We do not currently verify that our code runs in constant time, or that it does
not expose its secret inputs through some other means. Such verification would
be fundamentally different from ours, primarily because it would heavily depend
on the details of the deployment scenario. For example, processors implementing
the same instruction set can differ in which instructions leak their inputs
into timing, and CPU vendors as a rule do not publish documentation regarding
this. However, pretty-printing our low-level functions as C instead of Haskell
and running ct-verif to analyze that output would indeed clear it as “constant
time” in a common timing model.</p>

<h2 id="performance">Performance</h2>

<p>Some reviewers pointed out an 80x gap between our ed25519 signing implementation
and the best manual ones, which is much larger than the 6x gap for the handshake
benchmark that we focused on. This is because our ed25519 code consisted of
plugging our optimized code for subroutines into a verified but completely naive
implementation of the high-level signature scheme. We included the ed25519
implementation to show that the formal specifications of our code allow for
verified generic composition; we did not make any attempt at optimizing the
signature-specific high-level code. That said, the missing optimizations are
conceptually very similar to the ones we did implement, and we believe that it
would be rather straightforward to extend our library to include them.</p>

<p>Another comment was that the 6x gap for the handshake benchmark is still too big
for practical use. This is true for some cases of “practical use,” but we are
very confident that our approach has not hit a wall at this speed. There are
clear improvements to make that would close this gap. Furthermore, the 6x gap is
between our implementation and the very fastest of the handwritten ones. Our
code is only 40% slower than the code used in Chrome, in part because the
developers have significantly more confidence in the correctness of that code
compared to the fastest assembly code, whose slight variant “64-24k” contained
an elusive arithmetic bug as shown in table 1.</p>

<h1 id="answers-to-remaining-questions">Answers to Remaining Questions</h1>

<p><strong>What reusable insights does this paper provide for similar future tools?</strong></p>

<p>We believe our strategy generalizes to any arithmetic-heavy domain (including
those listed in the end of section 8), but as we have no evidence, just an
(informed) guess, we leave the determination of whether our method would suit
some particular application to the reader interested in that application.</p>

<p><strong>What exactly is the TCB?</strong></p>

<p>Coq and our whiteboard-level specs. As explained above, we require some kind
of tool that does register allocation and does the final translation to a
machine-specific assembly. So, if the tool used for that task is unverified,
it is part of the TCB for that particular instantiation of code. Although we
use GHC for this purpose in our benchmarks, it’s not the case in general that
GHC is part of our TCB. For a realistic use of our code, we would recommend
pretty-printing it into the language used by the overall project.</p>

<p><strong>How often do curve parameters change, and would they change more often if
there were a lower cost to reimplement high-performance implementations?</strong></p>

<p>The mathematical parameters have changed once in TLS (from a set of 4 to a set
of 2), and gaining adoption required the proposer to write optimized
implementations for every conceivable platform. The performance-oriented
parameters like carry chains and word size change when code is ported from one
CPU microarchitecture to another – OpenSSL currently contains several different
implementations of arithmetic modulo P256.</p>

<p>[0] Full definition of output syntax tree as found in the submitted code
tarball (the type variable <code class="language-plaintext highlighter-rouge">tZ</code> is instantiated with a type representing
machine words in the final output):</p>

<p>In <code class="language-plaintext highlighter-rouge">src/Reflection/Syntax.v</code>, lines 186-191:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Inductive exprf : flat_type -&gt; Type :=
| Const {t : flat_type} : interp_type t -&gt; exprf t
| Var {t} : var t -&gt; exprf t
| Op {t1 tR} : op t1 tR -&gt; exprf t1 -&gt; exprf tR
| LetIn : forall {tx}, exprf tx -&gt; forall {tC}, (interp_flat_type_gen var tx -&gt; exprf tC) -&gt; exprf tC
| Pair : forall {t1}, exprf t1 -&gt; forall {t2}, exprf t2 -&gt; exprf (Prod t1 t2).
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">src/Reflection/Z/Syntax.v</code>, lines 34-44:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Inductive op : flat_type base_type -&gt; flat_type base_type -&gt; Type :=
| Add : op (tZ * tZ) tZ
| Sub : op (tZ * tZ) tZ
| Mul : op (tZ * tZ) tZ
| Shl : op (tZ * tZ) tZ
| Shr : op (tZ * tZ) tZ
| Land : op (tZ * tZ) tZ
| Lor : op (tZ * tZ) tZ
| Neg (int_width : Z) : op tZ tZ
| Cmovne : op (tZ * tZ * tZ * tZ) tZ
| Cmovle : op (tZ * tZ * tZ * tZ) tZ.
</code></pre></div></div>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Jason Gross</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Jason Gross</li><li><a class="u-email" href="mailto:jgross@mit.edu">jgross@mit.edu</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/JasonGross"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">JasonGross</span></a></li><li><a href="https://www.twitter.com/diagram_chaser"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">diagram_chaser</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Personal website of Jason Gross</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
