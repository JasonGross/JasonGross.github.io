
<!-- This document was automatically generated with bibtex2html 1.99
     (see http://www.lri.fr/~filliatr/bibtex2html/),
     with the following command:
     bibtex2html -d -r -nodoc -nf videos videos -nf reviews reviews -nf full-bibliography "full bibliography" -nf bibliography bibliography -nf code-v "code (.v)" -nf code-html "code (.html)" -nf code-agda "code (.agda)" -nf artifact-zip "artifact (.zip)" -nf artifact-tar-gz "artifact (.tar.gz)" -nf code-github "project (<img src='media/GitHub-Mark/PNG/GitHub-Mark-32px.png' alt='GitHub' title='GitHub' style='height:1em; vertical-align:text-bottom' />)" -nf artifact-github "artifact (<img src='media/GitHub-Mark/PNG/GitHub-Mark-32px.png' alt='GitHub' title='GitHub' style='height:1em; vertical-align:text-bottom' />)" -nf original-url "original conference submission (.pdf)" -nf presentation-annotated-pptx "presentation (.pptx, annotated with notes)" -nf presentation-pptx "presentation (.pptx)" -nf presentation-youtube "presentation (YouTube)" -nf url-pptx .pptx -nf presentation-pdf "presentation (.pdf)" -nf presentation-odp "presentation (.odp)" -nf project-homepage "project homepage" -nf published-url publication -nf published-url-springer "publication (<div style="overflow: hidden; max-width: 1em; display: inline-block; vertical-align: middle"><img src="media/Springer-Mark/PNG/logo.png" alt="Springer" title="Springer" style="height: 1.5em; vertical-align: text-bottom"></div>)" -nf published-url-elsevier-geoderma "publication (<img src="media/ScienceDirect-Mark/svg/elsevier-non-solus-new-grey.svg" alt="ScienceDirect" title="ScienceDirect" style="height: 1em;vertical-align: text-bottom;">)" -nf acm-authorize-url "<img src='https://dl.acm.org/images/oa.gif' width='25' height='25' border='0' alt='ACM DL Author-ize Publication' title='ACM DL Author-ize Publication' style='vertical-align:middle'/>" -nf dspace-url DSpace@MIT --title Drafts -o jason-gross-drafts jason-gross-drafts.bib  -->

<h1>Drafts</h1>
<table>

<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="rewriting">1</a>]
</td>
<td class="bibtexitem">
Jason Gross, Andres Erbsen, Rajashree Agrawal, Jade Philipoom, and Adam
  Chlipala.
 Accelerating verified-compiler development with a verified rewriting
  engine, January 2022.
 Submitted to <a href="https://popl22.sigplan.org/">POPL 2022</a>.
[&nbsp;<a href="jason-gross-drafts_bib.html#rewriting">bib</a>&nbsp;| 
<a href="https://github.com/mit-plv/rewriter">project (<img src='media/GitHub-Mark/PNG/GitHub-Mark-32px.png' alt='GitHub' title='GitHub' style='height:1em; vertical-align:text-bottom' />)</a>&nbsp;| 
<a href="https://jasongross.github.io/papers/2022-rewriting-popl-draft.tar.gz">artifact (.tar.gz)</a>&nbsp;| 
<a href="https://jasongross.github.io/papers/2022-rewriting-popl-draft.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
Compilers are a prime target for formal verification, since compiler bugs invalidate higher-level correctness guarantees, but compiler changes may become more labor-intensive to implement, if they must come with proof patches.
One appealing approach is to present compilers as sets of algebraic rewrite rules, which a generic engine can apply efficiently.
Now each rewrite rule can be proved separately, with no need to revisit past proofs for other parts of the compiler.
We present the first realization of this idea, in the form of a framework for the Coq proof assistant.
Our new Coq command takes normal proved theorems and combines them automatically into fast compilers with proofs.
We applied our framework to improve the Fiat Cryptography toolchain for generating cryptographic arithmetic, producing an extracted command-line compiler that is about 1000&#215; faster while actually featuring simpler compiler-specific proofs.
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="lob-paper">2</a>]
</td>
<td class="bibtexitem">
Jason Gross, Jack Gallagher, and Benya Fallenstein.
 L&ouml;b's theorem: A functional pearl of dependently typed quining,
  March 2016.
 Submitted to <a href="http://conf.researchr.org/home/icfp-2016/">ICFP
  2016</a>.
[&nbsp;<a href="jason-gross-drafts_bib.html#lob-paper">bib</a>&nbsp;| 
<a href="https://github.com/JasonGross/lob-paper">project (<img src='media/GitHub-Mark/PNG/GitHub-Mark-32px.png' alt='GitHub' title='GitHub' style='height:1em; vertical-align:text-bottom' />)</a>&nbsp;| 
<a href="https://jasongross.github.io/papers/lob-paper/supplemental-nonymous.zip">artifact (.zip)</a>&nbsp;| 
<a href="https://people.csail.mit.edu/jgross/personal-website/papers/lob-paper/lob.lagda">code (.agda)</a>&nbsp;| 
<a href="https://jasongross.github.io/papers/lob-paper/html/lob.html">code (.html)</a>&nbsp;| 
<a href="https://jasongross.github.io/papers/lob-bibliography.html">bibliography</a>&nbsp;| 
<a href="https://jasongross.github.io/papers/2016-lob-icfp-2016-draft.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
L&ouml;b's theorem states that to prove that a proposition is provable, it
is sufficient to prove the proposition under the assumption that it is
provable.  The Curry-Howard isomorphism identifies formal proofs with
abstract syntax trees of programs; L&ouml;b's theorem thus implies, for
total languages which validate it, that self-interpreters are
impossible.  We formalize a few variations of L&ouml;b's theorem in Agda
using an inductive-inductive encoding of terms indexed over types.  We
verify the consistency of our formalizations relative to Agda by
giving them semantics via interpretation functions.
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="parsing-parse-trees">3</a>]
</td>
<td class="bibtexitem">
Jason Gross and Adam Chlipala.
 Parsing parses: A pearl of (dependently typed) programming and proof,
  August 2015.
 Submitted to <a href="http://icfpconference.org/icfp2015/cfp.html">ICFP
  2015</a>.
[&nbsp;<a href="jason-gross-drafts_bib.html#parsing-parse-trees">bib</a>&nbsp;| 
<a href="https://jasongross.github.io/papers/2015-parsing-parse-trees.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
We present a functional parser for arbitrary context-free grammars,
	together with soundness and completeness proofs, all inside Coq.
	 By exposing the parser in the right way with parametric polymorphism
	and dependent types, we are able to use the parser to prove its own
	soundness, and, with a little help from relational parametricity,
	prove its own completeness, too.  Of particular interest is one strange
	instantiation of the type and value parameters: by parsing <em>parse
	trees</em> instead of strings, we convince the parser to generate its
	own completeness proof.  We conclude with highlights of our experiences
	iterating through several versions of the Coq development, and some
	general lessons about dependently typed programming.
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="pldi-15-fiat-to-facade">4</a>]
</td>
<td class="bibtexitem">
Cl&eacute;ment Pit-Claudel, Peng Wang, Jason Gross, Ben Delaware, and Adam Chlipala.
 Correct-by-construction program derivation from specifications to
  assembly language, June 2015.
 Submitted to PLDI 2015.
[&nbsp;<a href="jason-gross-drafts_bib.html#pldi-15-fiat-to-facade">bib</a>&nbsp;| 
<a href="https://jasongross.github.io/papers/2015-fiat-to-facade.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
We present a Coq-based system to certify the entire process of implementing
	declarative mathematical specifications with efficient assembly code.
	That is, we produce formal assembly-code libraries with proofs, in
	the style of Hoare logic, demonstrating compatibility with relational
	specifications in higher-order logic. Most code-generation paths
	from high-level languages involve the introduction of garbage collection
	and other runtime support for source-level abstractions, but we generate
	code suitable for resource-constrained embedded systems, using manual
	memory management and in-place updating of heap-allocated data structures.
	We start from very high-level source code, applying the Fiat framework
	to refine set-theory expressions into functional programs; then we
	further apply Fiat's refinement tools to translate functional programs
	into Facade, a simple imperative language without a heap or aliasing;
	and finally we plug into the assembly-generation features of the
	Bedrock framework, where we link with handwritten data-structure
	implementations and their associated proofs. Each program refinement
	leads to a proved Hoare-logic specification for an assembly function,
	with no trust dependencies on any aspect of our synthesis process,
	which is highly automated.
</font></blockquote>

</td>
</tr>
</table><hr><p><em>This file was generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.99.</em></p>
